import * as SecureStore from 'expo-secure-store';

// Configura√ß√µes do Supabase
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!;

// Log das configura√ß√µes
console.log('üîß === CONFIGURA√á√ïES DA API ===');
console.log('üåê Supabase URL:', supabaseUrl);
console.log('üîë Supabase Anon Key:', supabaseAnonKey ? supabaseAnonKey.substring(0, 20) + '...' : 'N√ÉO DEFINIDA');

// Verificar se as vari√°veis est√£o definidas
if (!supabaseUrl || !supabaseAnonKey) {
  console.error('‚ùå === ERRO DE CONFIGURA√á√ÉO ===');
  console.error('Vari√°veis de ambiente n√£o definidas:');
  console.error('EXPO_PUBLIC_SUPABASE_URL:', supabaseUrl);
  console.error('EXPO_PUBLIC_SUPABASE_ANON_KEY:', supabaseAnonKey ? 'DEFINIDA' : 'N√ÉO DEFINIDA');
}

// Tipos para a API
export interface LoginResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number;
  token_type: string;
  user: {
    id: string;
    email: string;
    user_metadata?: any;
  };
}

export interface DashboardData {
  countTotal: number;
  countPaid: number;
  sumPaid: number;
  sumValorLiquido: number;
  valorLiquidoAdmin: number;
  countPending: number;
  sumPending: number;
  countRefused: number;
  sumRefused: number;
  countRefunded: number;
  sumRefunded: number;
  countChargedback: number;
  sumChargedback: number;
  taxaChargeback: number;
  taxaEstorno: number;
  ticketMedio: number;
  taxaAprovacao: number;
  conversionPix: number;
  conversionBoleto: number;
  conversionCard: number;
  countExpired: number;
  sumExpired: number;
  countPixTotal: number;
  countPixPaid: number;
  sumPix: number;
  sumPixPaid: number;
  countBoletoTotal: number;
  countBoletoPaid: number;
  sumBoleto: number;
  sumBoletoPaid: number;
  countCardTotal: number;
  countCardPaid: number;
  sumCard: number;
  sumCardPaid: number;
  currency: string;
  companies: {
    total: number;
    newlyCreated: number;
    withSales: number;
    withoutSales: number;
    existingWithoutSales: number;
    stoppedSelling: number;
  };
  projections: {
    financial: {
      totalAmount: number;
      avgTicket: number;
      totalOrders: number;
    };
    paymentMethods: {
      pix: { count: number; amount: number };
      boleto: { count: number; amount: number };
      card: { count: number; amount: number };
    };
    events: {
      refunded: number;
      chargeback: number;
      approved: number;
    };
    growth: {
      salesGrowth: number;
      approvalRate: number;
      companies: number;
    };
    conversion: {
      pix: number;
      boleto: number;
      card: number;
    };
    companies: {
      totalNew: number;
      withSales: number;
      withoutSales: number;
      willStopSelling: number;
    };
  };
  nextPeriodStart: string;
  nextPeriodEnd: string;
}

export interface WalletData {
  saldoPix: number;
  saldoCartao: number;
  valorReceber: number;
  reservaFinanceira: number;
  movimentacoes: WalletTransaction[];
}

export interface WalletTransaction {
  id: string;
  name: string;
  email: string;
  amount: number;
  date: string;
  type: 'pix' | 'card_approved' | 'card_failed';
  description?: string;
}

export interface ManagementData {
  // Dados de formas de pagamento
  pixSales: number;
  cardSales: number;
  boletoSales: number;
  totalSales: number;
  
  // Dados de vendas
  totalTransactions: number;
  averageTicket: number;
  
  // Dados de aprova√ß√£o
  pixApprovalRate: number;
  cardApprovalRate: number;
  boletoApprovalRate: number;
  
  // Dados de reembolsos
  refunds: number;
  chargebacks: number;
  
  // Dados de links
  activeLinks: number;
  linkSales: number;
}

export interface TransactionMetricsData {
  // Vendas Aprovadas
  approvedPixSales: number;
  approvedCardSales: number;
  approvedBoletoSales: number;
  totalApprovedSales: number;
  totalApprovedAmount: number;
  
  // Vendas Abandonadas
  abandonedPixSales: number;
  abandonedCardSales: number;
  abandonedBoletoSales: number;
  totalAbandonedSales: number;
  totalAbandonedAmount: number;
  
  // Comiss√µes
  pixCommission: number;
  cardCommission: number;
  boletoCommission: number;
  totalCommission: number;
  
  // Estornos
  pixRefunds: number;
  cardRefunds: number;
  boletoRefunds: number;
  totalRefunds: number;
}

export interface PaymentLink {
  id: string;
  nome: string;
  formas_de_pagamento: string[];
  valor: number;
  ativo: boolean;
  cor: string | null;
  descricao_cobranca: string | null;
  max_parcelamento: number;
  creator: string;
  company: string;
  created_at: string;
  updated_at: string | null;
  solicitar_endereco: boolean;
  image_logo: string | null;
}

export interface CreatePaymentLinkData {
  nome: string;
  formas_de_pagamento: string[];
  valor: number;
  ativo?: boolean;
  cor?: string;
  descricao_cobranca?: string;
  max_parcelamento?: number;
  solicitar_endereco?: boolean;
  image_logo?: string;
}

export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PixKey {
  id: string;
  key_type: string;
  key_value: string;
  description?: string;
  status: 'active' | 'inactive';
  created_at: string;
  updated_at: string;
}

export interface CreatePixKeyData {
  key_type: string;
  key_value: string;
  description?: string;
}

export interface UpdatePixKeyData {
  key_type?: string;
  key_value?: string;
  description?: string;
  status?: 'active' | 'inactive';
}

// Tipos para Configura√ß√µes
export interface UserData {
  id: string;
  fullname: string;
  email: string;
  phone: string;
  document: string;
  birthdate?: string;
  company: string;
  foto?: string | null;
}

// Fun√ß√£o utilit√°ria para extrair o primeiro nome
export const getFirstName = (fullname: string): string => {
  if (!fullname) return '';
  return fullname.split(' ')[0];
};

export interface CompanyData {
  id: string;
  name: string;
  fantasy_name?: string;
  taxid: string;
  website?: string;
  address: {
    street: string;
    number: string;
    neighborhood: string;
    city: string;
    state: string;
    zipcode: string;
    country: string;
  };
}

export interface CompanyRates {
  pix_fee_percentage: number;
  pix_fee_fixed: number;
  card_fee_percentage: number;
  card_fee_fixed: number;
  boleto_fee_percentage: number;
  boleto_fee_fixed: number;
  withdrawal_fee_percentage: number;
  withdrawal_fee_fixed: number;
  fee_type_pix?: string;
  fee_type_card?: string;
  fee_type_boleto?: string;
  fee_type_withdrawal?: string;
}

export interface TaxSimulationRequest {
  company_id: string;
  valor: number;
  payment_method: 'PIX' | 'CARD' | 'BOLETO';
  parcelas: number;
}

export interface TaxSimulationResponse {
  taxaIntermediacao: string;
  totalTaxas: string;
  valorLiquido: string;
}

// Classe principal da API
class KingPayAPI {
  private accessToken: string | null = null;

  // M√©todo para fazer login
  async login(email: string, password: string): Promise<ApiResponse<LoginResponse>> {
    try {
      console.log('üîê === INICIANDO LOGIN ===');
      console.log('üìß Email:', email);
      
      // LIMPAR TODOS OS TOKENS ANTES DO LOGIN
      await this.clearTokenCache();
      console.log('üßπ Tokens anteriores removidos');
      
      const requestBody = {
        email,
        password,
      };
      
      console.log('üì§ === REQUISI√á√ÉO ===');
      console.log('M√©todo: POST');
      console.log('URL:', `${supabaseUrl}/auth/v1/token?grant_type=password`);
      console.log('Headers:', {
        'Content-Type': 'application/json',
        'apikey': supabaseAnonKey.substring(0, 20) + '...'
      });
      console.log('Body:', JSON.stringify(requestBody, null, 2));
      
      const response = await fetch(`${supabaseUrl}/auth/v1/token?grant_type=password`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': supabaseAnonKey,
        },
        body: JSON.stringify(requestBody),
      });

      const data = await response.json();
      
      console.log('üì• === RESPOSTA ===');
      console.log('Status:', response.status);
      console.log('Headers:', Object.fromEntries(response.headers.entries()));
      console.log('Data:', JSON.stringify(data, null, 2));

      if (response.ok) {
        console.log('‚úÖ === LOGIN BEM-SUCEDIDO ===');
        console.log('üë§ User ID:', data.user.id);
        console.log('üìß User Email:', data.user.email);
        console.log('üîë Access Token:', data.access_token.substring(0, 20) + '...');
        
        // SALVAR APENAS O NOVO TOKEN
        await SecureStore.setItemAsync('access_token', data.access_token);
        await SecureStore.setItemAsync('refresh_token', data.refresh_token);
        await SecureStore.setItemAsync('user_id', data.user.id);
        
        // Atualizar token em mem√≥ria
        this.accessToken = data.access_token;
        
        console.log('üíæ Novo token salvo no SecureStore');
        console.log('üîÑ Token em mem√≥ria atualizado');
        
        return {
          success: true,
          data,
        };
      } else {
        console.log('‚ùå === ERRO NO LOGIN ===');
        console.log('Erro:', data.error_description || data.error || 'Erro desconhecido');
        
        // Em caso de erro, garantir que n√£o h√° tokens
        await this.clearTokenCache();
        
        return {
          success: false,
          error: data.error_description || data.error || 'Erro no login',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO ===');
      console.error('Erro:', error);
      
      // Em caso de erro, garantir que n√£o h√° tokens
      await this.clearTokenCache();
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para buscar dados do dashboard
  async getDashboardData(startDate: string, endDate: string, companyId?: string): Promise<ApiResponse<DashboardData>> {
    try {
      console.log('üìä === BUSCANDO DADOS DO DASHBOARD ===');
      console.log('üìÖ Per√≠odo:', `${startDate} at√© ${endDate}`);
      console.log('üè¢ Company ID:', companyId || 'N/A');
      
      const token = await this.getStoredToken();
      if (!token) {
        console.log('‚ùå Token n√£o encontrado');
        return { success: false, error: 'Token n√£o encontrado' };
      }

      const params = new URLSearchParams({
        start_date: startDate,
        end_date: endDate,
        ...(companyId && { company_id: companyId })
      });

      const url = `${supabaseUrl}/functions/v1/dados-dashboard?${params}`;
      
      console.log('üì§ === REQUISI√á√ÉO DASHBOARD ===');
      console.log('M√©todo: POST');
      console.log('URL:', url);
      console.log('Headers:', {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token.substring(0, 20)}...`
      });
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({}),
      });

      const data = await response.json();
      
      console.log('üì• === RESPOSTA DASHBOARD ===');
      console.log('Status:', response.status);
      console.log('Data:', JSON.stringify(data, null, 2));

      if (response.ok) {
        console.log('‚úÖ === DADOS DO DASHBOARD OBTIDOS ===');
        console.log('üí∞ Total de vendas:', data.sumPaid);
        console.log('üìà Taxa de aprova√ß√£o:', data.taxaAprovacao);
        console.log('üé´ Ticket m√©dio:', data.ticketMedio);
        
        return {
          success: true,
          data,
        };
      } else {
        console.log('‚ùå === ERRO AO BUSCAR DADOS ===');
        console.log('Erro:', data.error || 'Erro desconhecido');
        
        return {
          success: false,
          error: data.error || 'Erro ao buscar dados do dashboard',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO DASHBOARD ===');
      console.error('Erro:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para buscar dados da carteira
  async getWalletData(): Promise<ApiResponse<WalletData>> {
    try {
      console.log('üí≥ === BUSCANDO DADOS DA CARTEIRA ===');
      
      const token = await this.getStoredToken();
      if (!token) {
        console.log('‚ùå Token n√£o encontrado');
        return { success: false, error: 'Token n√£o encontrado' };
      }

      // Usar dados do dashboard para a carteira
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 30);

      const startDateStr = startDate.toISOString().split('T')[0];
      const endDateStr = endDate.toISOString().split('T')[0];

      const dashboardResponse = await this.getDashboardData(startDateStr, endDateStr);
      
      if (dashboardResponse.success && dashboardResponse.data) {
        // Mapear dados do dashboard para a carteira (sem dados mockados)
        const walletData: WalletData = {
          saldoPix: dashboardResponse.data.sumPixPaid || 0,
          saldoCartao: dashboardResponse.data.sumCardPaid || 0,
          valorReceber: dashboardResponse.data.sumPending || 0,
          reservaFinanceira: dashboardResponse.data.sumValorLiquido || 0,
          movimentacoes: [], // Array vazio - sem dados mockados
        };

        console.log('‚úÖ === DADOS DA CARTEIRA OBTIDOS ===');
        console.log('üí∞ Saldo PIX:', walletData.saldoPix);
        console.log('üí≥ Saldo Cart√£o:', walletData.saldoCartao);
        console.log('üìà Valor a Receber:', walletData.valorReceber);
        console.log('üè¶ Reserva Financeira:', walletData.reservaFinanceira);
        console.log('üìã Movimenta√ß√µes:', walletData.movimentacoes.length);
        
        return {
          success: true,
          data: walletData,
        };
      } else {
        return {
          success: false,
          error: dashboardResponse.error || 'Erro ao buscar dados da carteira',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO CARTEIRA ===');
      console.error('Erro:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para buscar dados de gest√£o
  async getManagementData(): Promise<ApiResponse<ManagementData>> {
    try {
      console.log('üìä === BUSCANDO DADOS DE GEST√ÉO ===');
      
      const token = await this.getStoredToken();
      if (!token) {
        console.log('‚ùå Token n√£o encontrado');
        return { success: false, error: 'Token n√£o encontrado' };
      }

      // Buscar dados do dashboard
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 30);

      const startDateStr = startDate.toISOString().split('T')[0];
      const endDateStr = endDate.toISOString().split('T')[0];

      const dashboardResponse = await this.getDashboardData(startDateStr, endDateStr);
      
      if (dashboardResponse.success && dashboardResponse.data) {
        // Buscar links de pagamento
        const linksResponse = await this.getPaymentLinks();
        
        const managementData: ManagementData = {
          // Dados de formas de pagamento
          pixSales: dashboardResponse.data.sumPix || 0,
          cardSales: dashboardResponse.data.sumCard || 0,
          boletoSales: dashboardResponse.data.sumBoleto || 0,
          totalSales: (dashboardResponse.data.sumPix || 0) + (dashboardResponse.data.sumCard || 0) + (dashboardResponse.data.sumBoleto || 0),
          
          // Dados de vendas
          totalTransactions: dashboardResponse.data.countTotal || 0,
          averageTicket: dashboardResponse.data.ticketMedio || 0,
          
          // Dados de aprova√ß√£o
          pixApprovalRate: dashboardResponse.data.conversionPix || 0,
          cardApprovalRate: dashboardResponse.data.conversionCard || 0,
          boletoApprovalRate: dashboardResponse.data.conversionBoleto || 0,
          
          // Dados de reembolsos
          refunds: dashboardResponse.data.sumRefunded || 0,
          chargebacks: dashboardResponse.data.sumChargedback || 0,
          
          // Dados de links
          activeLinks: linksResponse.success ? linksResponse.data?.filter(link => link.ativo).length || 0 : 0,
          linkSales: dashboardResponse.data.countTotal || 0, // N√∫mero total de transa√ß√µes (vendas)
        };

        console.log('‚úÖ === DADOS DE GEST√ÉO OBTIDOS ===');
        console.log('üí∞ Vendas PIX:', managementData.pixSales);
        console.log('üí≥ Vendas Cart√£o:', managementData.cardSales);
        console.log('üìÑ Vendas Boleto:', managementData.boletoSales);
        console.log('üìä Total de Vendas:', managementData.totalSales);
        console.log('üîó Links Ativos:', managementData.activeLinks);
        console.log('üìà N√∫mero de Vendas:', managementData.linkSales);
        
        return {
          success: true,
          data: managementData,
        };
      } else {
        return {
          success: false,
          error: dashboardResponse.error || 'Erro ao buscar dados de gest√£o',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO GEST√ÉO ===');
      console.error('Erro:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para buscar links de pagamento
  async getPaymentLinks(): Promise<ApiResponse<PaymentLink[]>> {
    try {
      console.log('üîó === BUSCANDO LINKS DE PAGAMENTO ===');
      
      const token = await this.getStoredToken();
      if (!token) {
        console.log('‚ùå Token n√£o encontrado');
        return { success: false, error: 'Token n√£o encontrado' };
      }

      // Obter user ID do token
      const userId = await SecureStore.getItemAsync('user_id');
      if (!userId) {
        console.log('‚ùå User ID n√£o encontrado');
        return { success: false, error: 'User ID n√£o encontrado' };
      }

      // Buscar dados do usu√°rio para obter o company ID
      const userData = await this.getUserData(userId);
      if (!userData.success || !userData.data) {
        console.log('‚ùå N√£o foi poss√≠vel obter dados do usu√°rio');
        return { success: false, error: 'N√£o foi poss√≠vel obter dados do usu√°rio' };
      }

      // A resposta da API tem estrutura { success: true, user: { company: "..." } }
      const responseData = userData.data as any;
      const companyId = responseData.user?.company || responseData.company;
      if (!companyId) {
        console.log('‚ùå Company ID n√£o encontrado');
        return { success: false, error: 'Company ID n√£o encontrado' };
      }

      console.log('üè¢ Company ID:', companyId);

      // Construir URL com filtro por company
      const url = `${supabaseUrl}/functions/v1/link-pagamentos?company=${companyId}`;
      
      console.log('üì§ === REQUISI√á√ÉO LINKS ===');
      console.log('M√©todo: GET');
      console.log('URL:', url);
      console.log('Headers:', {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token.substring(0, 20)}...`
      });
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
      });

      const data = await response.json();
      
      console.log('üì• === RESPOSTA LINKS ===');
      console.log('Status:', response.status);
      console.log('Data:', JSON.stringify(data, null, 2));

      if (response.ok) {
        console.log('‚úÖ === LINKS OBTIDOS ===');
        console.log('üîó Total de links:', data.data?.length || 0);
        console.log('‚úÖ Links ativos:', data.data?.filter((link: PaymentLink) => link.ativo).length || 0);
        
        // Log detalhado dos links obtidos
        if (data.data && data.data.length > 0) {
          console.log('üìã Links obtidos:');
          data.data.forEach((link: PaymentLink, index: number) => {
            console.log(`  ${index + 1}. ${link.nome} (R$ ${link.valor}) - Criado por: ${link.creator} - Company: ${link.company}`);
          });
        }
        
        return {
          success: true,
          data: data.data || [],
        };
      } else {
        console.log('‚ùå === ERRO AO BUSCAR LINKS ===');
        console.log('Erro:', data.error || 'Erro desconhecido');
        
        return {
          success: false,
          error: data.error || 'Erro ao buscar links de pagamento',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO LINKS ===');
      console.error('Erro:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para criar um novo link de pagamento
  async createPaymentLink(data: CreatePaymentLinkData): Promise<ApiResponse<PaymentLink>> {
    try {
      console.log('üîó === CRIANDO NOVO LINK DE PAGAMENTO ===');
      console.log('Dados:', JSON.stringify(data, null, 2));

      const token = await this.getStoredToken();
      if (!token) {
        console.log('‚ùå Token n√£o encontrado');
        return { success: false, error: 'Token n√£o encontrado' };
      }

      const url = `${supabaseUrl}/functions/v1/link-pagamentos`;
      
      console.log('üì§ === REQUISI√á√ÉO CRIAR LINK ===');
      console.log('M√©todo: POST');
      console.log('URL:', url);
      console.log('Headers:', {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token.substring(0, 20)}...`
      });
      console.log('Body:', JSON.stringify(data, null, 2));
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(data),
      });

      const result = await response.json();
      
      console.log('üì• === RESPOSTA CRIAR LINK ===');
      console.log('Status:', response.status);
      console.log('Data:', JSON.stringify(result, null, 2));

      if (response.ok) {
        console.log('‚úÖ === LINK DE PAGAMENTO CRIADO ===');
        return {
          success: true,
          data: result,
        };
      } else {
        console.log('‚ùå === ERRO AO CRIAR LINK ===');
        console.log('Erro:', result.error || 'Erro desconhecido');
        return {
          success: false,
          error: result.error || 'Erro ao criar link de pagamento',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO CRIAR LINK ===');
      console.error('Erro:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para atualizar um link de pagamento (cancelar/editar)
  async updatePaymentLink(linkId: string, data: Partial<CreatePaymentLinkData>): Promise<ApiResponse<PaymentLink>> {
    try {
      console.log('üîÑ === ATUALIZANDO LINK DE PAGAMENTO ===');
      console.log('Link ID:', linkId);
      console.log('Dados:', JSON.stringify(data, null, 2));

      const token = await this.getStoredToken();
      if (!token) {
        console.log('‚ùå Token n√£o encontrado');
        return { success: false, error: 'Token n√£o encontrado' };
      }

      const url = `${supabaseUrl}/functions/v1/link-pagamentos/${linkId}`;
      
      console.log('üì§ === REQUISI√á√ÉO ATUALIZAR LINK ===');
      console.log('M√©todo: PATCH');
      console.log('URL:', url);
      console.log('Headers:', {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token.substring(0, 20)}...`
      });
      console.log('Body:', JSON.stringify(data, null, 2));
      
      const response = await fetch(url, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(data),
      });

      const result = await response.json();
      
      console.log('üì• === RESPOSTA ATUALIZAR LINK ===');
      console.log('Status:', response.status);
      console.log('Data:', JSON.stringify(result, null, 2));

      if (response.ok) {
        console.log('‚úÖ === LINK ATUALIZADO COM SUCESSO ===');
        return {
          success: true,
          data: result,
        };
      } else {
        console.log('‚ùå === ERRO AO ATUALIZAR LINK ===');
        console.log('Erro:', result.error || 'Erro desconhecido');
        return {
          success: false,
          error: result.error || 'Erro ao atualizar link de pagamento',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO ATUALIZAR ===');
      console.error('Erro:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para buscar dados de m√©tricas de transa√ß√µes
  async getTransactionMetricsData(): Promise<ApiResponse<TransactionMetricsData>> {
    try {
      console.log('üìä === BUSCANDO M√âTRICAS DE TRANSA√á√ïES ===');
      
      const token = await this.getStoredToken();
      if (!token) {
        console.log('‚ùå Token n√£o encontrado');
        return { success: false, error: 'Token n√£o encontrado' };
      }

      // Buscar dados do dashboard
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 30);

      const startDateStr = startDate.toISOString().split('T')[0];
      const endDateStr = endDate.toISOString().split('T')[0];

      const dashboardResponse = await this.getDashboardData(startDateStr, endDateStr);
      
      if (dashboardResponse.success && dashboardResponse.data) {
        const data = dashboardResponse.data;
        
        // Calcular m√©tricas baseadas nos dados do dashboard
        const transactionMetrics: TransactionMetricsData = {
          // Vendas Aprovadas
          approvedPixSales: data.countPixPaid || 0,
          approvedCardSales: data.countCardPaid || 0,
          approvedBoletoSales: data.countBoletoPaid || 0,
          totalApprovedSales: (data.countPixPaid || 0) + (data.countCardPaid || 0) + (data.countBoletoPaid || 0),
          totalApprovedAmount: (data.sumPixPaid || 0) + (data.sumCardPaid || 0) + (data.sumBoletoPaid || 0),
          
          // Vendas Abandonadas (calculado como total - aprovadas)
          abandonedPixSales: (data.countPixTotal || 0) - (data.countPixPaid || 0),
          abandonedCardSales: (data.countCardTotal || 0) - (data.countCardPaid || 0),
          abandonedBoletoSales: (data.countBoletoTotal || 0) - (data.countBoletoPaid || 0),
          totalAbandonedSales: (data.countTotal || 0) - (data.countPaid || 0),
          totalAbandonedAmount: (data.sumPix || 0) + (data.sumCard || 0) + (data.sumBoleto || 0) - (data.sumPaid || 0),
          
          // Comiss√µes (estimativa baseada em 2% das vendas aprovadas)
          pixCommission: Math.round((data.sumPixPaid || 0) * 0.02),
          cardCommission: Math.round((data.sumCardPaid || 0) * 0.02),
          boletoCommission: Math.round((data.sumBoletoPaid || 0) * 0.02),
          totalCommission: Math.round(((data.sumPixPaid || 0) + (data.sumCardPaid || 0) + (data.sumBoletoPaid || 0)) * 0.02),
          
          // Estornos
          pixRefunds: data.sumRefunded || 0, // Usando o total de estornos
          cardRefunds: data.sumRefunded || 0, // Usando o total de estornos
          boletoRefunds: data.sumRefunded || 0, // Usando o total de estornos
          totalRefunds: data.sumRefunded || 0,
        };

        console.log('‚úÖ === M√âTRICAS DE TRANSA√á√ïES OBTIDAS ===');
        console.log('‚úÖ Vendas Aprovadas:', transactionMetrics.totalApprovedSales);
        console.log('üí∞ Valor Aprovado:', transactionMetrics.totalApprovedAmount);
        console.log('‚ùå Vendas Abandonadas:', transactionMetrics.totalAbandonedSales);
        console.log('üí∞ Valor Abandonado:', transactionMetrics.totalAbandonedAmount);
        console.log('üí∏ Comiss√£o Total:', transactionMetrics.totalCommission);
        console.log('üîÑ Estornos Total:', transactionMetrics.totalRefunds);
        
        return {
          success: true,
          data: transactionMetrics,
        };
      } else {
        return {
          success: false,
          error: dashboardResponse.error || 'Erro ao buscar m√©tricas de transa√ß√µes',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO M√âTRICAS ===');
      console.error('Erro:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para buscar detalhes de um link de pagamento espec√≠fico
  async getPaymentLinkDetails(linkId: string): Promise<ApiResponse<PaymentLink>> {
    try {
      console.log('üîç === BUSCANDO DETALHES DO LINK ===');
      console.log('Link ID:', linkId);

      const token = await this.getStoredToken();
      if (!token) {
        console.log('‚ùå Token n√£o encontrado');
        return { success: false, error: 'Token n√£o encontrado' };
      }

      const url = `${supabaseUrl}/functions/v1/link-pagamento-view/${linkId}`;
      
      console.log('üì§ === REQUISI√á√ÉO DETALHES LINK ===');
      console.log('M√©todo: GET');
      console.log('URL:', url);
      console.log('Headers:', {
        'Authorization': `Bearer ${token.substring(0, 20)}...`
      });
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      });

      const result = await response.json();
      
      console.log('üì• === RESPOSTA DETALHES LINK ===');
      console.log('Status:', response.status);
      console.log('Data:', JSON.stringify(result, null, 2));

      if (response.ok) {
        console.log('‚úÖ === DETALHES DO LINK OBTIDOS ===');
        return {
          success: true,
          data: result,
        };
      } else {
        console.log('‚ùå === ERRO AO BUSCAR DETALHES ===');
        console.log('Erro:', result.error || 'Erro desconhecido');
        return {
          success: false,
          error: result.error || 'Erro ao buscar detalhes do link',
        };
      }
    } catch (error) {
      console.log('üí• === ERRO DE CONEX√ÉO DETALHES ===');
      console.error('Erro:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro de conex√£o',
      };
    }
  }

  // M√©todo para fazer logout
  async logout(): Promise<void> {
    try {
      console.log('üö™ === INICIANDO LOGOUT ===');
      
      // Usar m√©todo de limpeza de cache
      await this.clearTokenCache();
      
      console.log('‚úÖ Logout conclu√≠do com sucesso');
    } catch (error) {
      console.error('‚ùå Erro ao fazer logout:', error);
    }
  }

  // M√©todo para obter token armazenado
  async getStoredToken(): Promise<string | null> {
    try {
      // Sempre buscar diretamente do SecureStore para garantir token atual
      const token = await SecureStore.getItemAsync('access_token');
      
      if (token) {
        // Atualizar token em mem√≥ria apenas se encontrado
        this.accessToken = token;
        console.log('üîë Token obtido do SecureStore');
        return token;
      } else {
        // Garantir que n√£o h√° token em mem√≥ria se n√£o encontrado
        this.accessToken = null;
        console.log('‚ùå Token n√£o encontrado no SecureStore');
        return null;
      }
    } catch (error) {
      console.error('‚ùå Erro ao obter token:', error);
      this.accessToken = null;
      return null;
    }
  }

  // M√©todo para verificar se o usu√°rio est√° autenticado
  async isAuthenticated(): Promise<boolean> {
    try {
      console.log('üîç === VERIFICANDO AUTENTICA√á√ÉO ===');
      
      // Primeiro validar e limpar tokens √≥rf√£os
      await this.validateAndCleanTokens();
      
      // Buscar token diretamente do SecureStore
      const token = await SecureStore.getItemAsync('access_token');
      
      if (!token) {
        console.log('‚ùå Token n√£o encontrado no SecureStore');
        // Garantir que n√£o h√° token em mem√≥ria
        this.accessToken = null;
        return false;
      }
      
      // Verificar se o token n√£o est√° expirado (verifica√ß√£o b√°sica)
      try {
        const tokenData = JSON.parse(atob(token.split('.')[1]));
        const currentTime = Math.floor(Date.now() / 1000);
        
        if (tokenData.exp && tokenData.exp < currentTime) {
          console.log('‚ùå Token expirado, removendo...');
          await this.clearTokenCache();
          return false;
        }
        
        console.log('‚úÖ Token v√°lido encontrado');
        this.accessToken = token;
        return true;
      } catch (parseError) {
        console.log('‚ùå Token inv√°lido, removendo...');
        await this.clearTokenCache();
        return false;
      }
    } catch (error) {
      console.log('‚ùå Erro ao verificar autentica√ß√£o:', error);
      // Em caso de erro, limpar tokens
      await this.clearTokenCache();
      return false;
    }
  }

  // M√©todo para limpar cache de tokens
  async clearTokenCache(): Promise<void> {
    try {
      console.log('üßπ === LIMPANDO CACHE DE TOKENS ===');
      
      // Limpar token em mem√≥ria PRIMEIRO
      this.accessToken = null;
      console.log('üóëÔ∏è Token em mem√≥ria removido');
      
      // Remover TODOS os tokens do SecureStore
      await SecureStore.deleteItemAsync('access_token');
      await SecureStore.deleteItemAsync('refresh_token');
      await SecureStore.deleteItemAsync('user_id');
      
      console.log('üóëÔ∏è Tokens removidos do SecureStore');
      console.log('‚úÖ Cache de tokens completamente limpo');
    } catch (error) {
      console.error('‚ùå Erro ao limpar cache de tokens:', error);
      // Mesmo com erro, garantir que token em mem√≥ria est√° limpo
      this.accessToken = null;
    }
  }

  // M√©todo para verificar e limpar tokens √≥rf√£os
  async validateAndCleanTokens(): Promise<void> {
    try {
      console.log('üîç === VALIDANDO TOKENS ===');
      
      const accessToken = await SecureStore.getItemAsync('access_token');
      const refreshToken = await SecureStore.getItemAsync('refresh_token');
      const userId = await SecureStore.getItemAsync('user_id');
      
      // Se h√° token mas n√£o h√° user_id, limpar tudo
      if (accessToken && !userId) {
        console.log('‚ö†Ô∏è Token √≥rf√£o encontrado (sem user_id), removendo...');
        await this.clearTokenCache();
        return;
      }
      
      // Se h√° user_id mas n√£o h√° token, limpar tudo
      if (userId && !accessToken) {
        console.log('‚ö†Ô∏è User ID √≥rf√£o encontrado (sem token), removendo...');
        await this.clearTokenCache();
        return;
      }
      
      // Se h√° token, verificar se est√° v√°lido
      if (accessToken) {
        try {
          const tokenData = JSON.parse(atob(accessToken.split('.')[1]));
          const currentTime = Math.floor(Date.now() / 1000);
          
          if (tokenData.exp && tokenData.exp < currentTime) {
            console.log('‚ö†Ô∏è Token expirado encontrado, removendo...');
            await this.clearTokenCache();
            return;
          }
          
          console.log('‚úÖ Tokens v√°lidos encontrados');
        } catch (parseError) {
          console.log('‚ö†Ô∏è Token inv√°lido encontrado, removendo...');
          await this.clearTokenCache();
          return;
        }
      }
      
      console.log('‚úÖ Valida√ß√£o de tokens conclu√≠da');
    } catch (error) {
      console.error('‚ùå Erro ao validar tokens:', error);
      // Em caso de erro, limpar tudo
      await this.clearTokenCache();
    }
  }



  // M√©todos para Chaves PIX
  async getPixKeys(): Promise<ApiResponse<PixKey[]>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('üîë === BUSCANDO CHAVES PIX ===');
      console.log('üì§ === REQUISI√á√ÉO CHAVES PIX ===');
      console.log('M√©todo: GET');
      console.log('URL:', `${supabaseUrl}/functions/v1/pix-key`);
      console.log('Headers:', { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' });

      const response = await fetch(`${supabaseUrl}/functions/v1/pix-key`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      console.log('üì• === RESPOSTA CHAVES PIX ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        return { success: true, data: data.data || [] };
      } else {
        return { success: false, error: data.error || 'Erro ao buscar chaves PIX' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO CHAVES PIX ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao buscar chaves PIX' };
    }
  }

  async createPixKey(pixKeyData: CreatePixKeyData): Promise<ApiResponse<PixKey>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('üîë === CRIANDO CHAVE PIX ===');
      console.log('üì§ === REQUISI√á√ÉO CRIAR CHAVE PIX ===');
      console.log('M√©todo: POST');
      console.log('URL:', `${supabaseUrl}/functions/v1/pix-key`);
      console.log('Headers:', { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' });
      console.log('Body:', pixKeyData);

      const response = await fetch(`${supabaseUrl}/functions/v1/pix-key`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(pixKeyData),
      });

      console.log('üì• === RESPOSTA CRIAR CHAVE PIX ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        return { success: true, data: data.data || data };
      } else {
        return { success: false, error: data.error || 'Erro ao criar chave PIX' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO CRIAR CHAVE PIX ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao criar chave PIX' };
    }
  }

  async updatePixKey(id: string, pixKeyData: UpdatePixKeyData): Promise<ApiResponse<PixKey>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('üîë === ATUALIZANDO CHAVE PIX ===');
      console.log('üì§ === REQUISI√á√ÉO ATUALIZAR CHAVE PIX ===');
      console.log('M√©todo: PUT');
      console.log('URL:', `${supabaseUrl}/functions/v1/pix-key/${id}`);
      console.log('Headers:', { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' });
      console.log('Body:', pixKeyData);

      const response = await fetch(`${supabaseUrl}/functions/v1/pix-key/${id}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(pixKeyData),
      });

      console.log('üì• === RESPOSTA ATUALIZAR CHAVE PIX ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        return { success: true, data: data.data || data };
      } else {
        return { success: false, error: data.error || 'Erro ao atualizar chave PIX' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO ATUALIZAR CHAVE PIX ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao atualizar chave PIX' };
    }
  }

  async deletePixKey(id: string): Promise<ApiResponse<boolean>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('üîë === EXCLUINDO CHAVE PIX ===');
      console.log('üì§ === REQUISI√á√ÉO EXCLUIR CHAVE PIX ===');
      console.log('M√©todo: DELETE');
      console.log('URL:', `${supabaseUrl}/functions/v1/pix-key/${id}`);
      console.log('Headers:', { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' });

      const response = await fetch(`${supabaseUrl}/functions/v1/pix-key/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      console.log('üì• === RESPOSTA EXCLUIR CHAVE PIX ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        return { success: true, data: true };
      } else {
        return { success: false, error: data.error || 'Erro ao excluir chave PIX' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO EXCLUIR CHAVE PIX ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao excluir chave PIX' };
    }
  }

  // M√©todos para Configura√ß√µes
  async getUserData(userId: string): Promise<ApiResponse<UserData>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('üë§ === BUSCANDO DADOS DO USU√ÅRIO ===');
      console.log('üì§ === REQUISI√á√ÉO DADOS DO USU√ÅRIO ===');
      console.log('M√©todo: GET');
      console.log('URL:', `${supabaseUrl}/functions/v1/users/${userId}`);
      console.log('Headers:', { Authorization: `Bearer ${token}` });

      const response = await fetch(`${supabaseUrl}/functions/v1/users/${userId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      console.log('üì• === RESPOSTA DADOS DO USU√ÅRIO ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        return { success: true, data: data.data || data };
      } else {
        return { success: false, error: data.error || 'Erro ao buscar dados do usu√°rio' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO BUSCAR DADOS DO USU√ÅRIO ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao buscar dados do usu√°rio' };
    }
  }

  async updateUserData(userId: string, userData: Partial<UserData>): Promise<ApiResponse<UserData>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('‚úèÔ∏è === ATUALIZANDO DADOS DO USU√ÅRIO ===');
      console.log('üì§ === REQUISI√á√ÉO ATUALIZAR USU√ÅRIO ===');
      console.log('M√©todo: PATCH');
      console.log('URL:', `${supabaseUrl}/functions/v1/users/${userId}/edit`);
      console.log('Headers:', { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' });
      console.log('Body:', userData);

      const response = await fetch(`${supabaseUrl}/functions/v1/users/${userId}/edit`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
      });

      console.log('üì• === RESPOSTA ATUALIZAR USU√ÅRIO ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        return { success: true, data: data.data || data };
      } else {
        return { success: false, error: data.error || 'Erro ao atualizar dados do usu√°rio' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO ATUALIZAR USU√ÅRIO ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao atualizar dados do usu√°rio' };
    }
  }

  async getCompanyData(): Promise<ApiResponse<CompanyData>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('üè¢ === BUSCANDO DADOS DA EMPRESA ===');
      console.log('üì§ === REQUISI√á√ÉO DADOS DA EMPRESA ===');
      console.log('M√©todo: GET');
      console.log('URL:', `${supabaseUrl}/functions/v1/config-companie-view`);
      console.log('Headers:', { Authorization: `Bearer ${token}` });

      const response = await fetch(`${supabaseUrl}/functions/v1/config-companie-view`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      console.log('üì• === RESPOSTA DADOS DA EMPRESA ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        return { success: true, data: data.data || data };
      } else {
        return { success: false, error: data.error || 'Erro ao buscar dados da empresa' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO BUSCAR DADOS DA EMPRESA ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao buscar dados da empresa' };
    }
  }

  async getCompanyRates(companyId: string): Promise<ApiResponse<CompanyRates>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('üí∞ === BUSCANDO TAXAS DA EMPRESA ===');
      console.log('üì§ === REQUISI√á√ÉO TAXAS DA EMPRESA ===');
      console.log('M√©todo: GET');
      console.log('URL:', `${supabaseUrl}/functions/v1/companies/${companyId}/taxas`);
      console.log('Headers:', { Authorization: `Bearer ${token}` });

      const response = await fetch(`${supabaseUrl}/functions/v1/companies/${companyId}/taxas`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      console.log('üì• === RESPOSTA TAXAS DA EMPRESA ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        // A resposta da API pode vir aninhada em um campo 'taxas'
        const taxasData = data.taxas || data.data || data;
        return { success: true, data: taxasData };
      } else {
        return { success: false, error: data.error || 'Erro ao buscar taxas da empresa' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO BUSCAR TAXAS DA EMPRESA ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao buscar taxas da empresa' };
    }
  }

  async simulateTaxes(simulationData: TaxSimulationRequest): Promise<ApiResponse<TaxSimulationResponse>> {
    try {
      const token = await this.getStoredToken();
      if (!token) {
        return { success: false, error: 'Token n√£o encontrado' };
      }

      console.log('üßÆ === SIMULANDO TAXAS ===');
      console.log('üì§ === REQUISI√á√ÉO SIMULAR TAXAS ===');
      console.log('M√©todo: POST');
      console.log('URL:', `${supabaseUrl}/functions/v1/taxas`);
      console.log('Headers:', { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' });
      console.log('Body:', simulationData);

      const response = await fetch(`${supabaseUrl}/functions/v1/taxas`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(simulationData),
      });

      console.log('üì• === RESPOSTA SIMULAR TAXAS ===');
      console.log('Status:', response.status);

      const data = await response.json();
      console.log('Data:', data);

      if (response.ok) {
        return { success: true, data: data.data || data };
      } else {
        return { success: false, error: data.error || 'Erro ao simular taxas' };
      }
    } catch (error) {
      console.log('üí• === ERRO INESPERADO SIMULAR TAXAS ===');
      console.log('Erro:', error);
      return { success: false, error: 'Erro inesperado ao simular taxas' };
    }
  }
}

// Inst√¢ncia √∫nica da API
export const api = new KingPayAPI();

export default api;
